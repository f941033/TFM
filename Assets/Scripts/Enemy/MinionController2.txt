using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;

public class MinionController2 : MonoBehaviour
{
    /* --------------- Ajustes visibles en el Inspector --------------- */
    [Header("Detección")]
    [SerializeField] float detectionRadius = 8f;
    [SerializeField] LayerMask enemyLayer;
    [SerializeField] Tilemap obstacleTilemap;
    [SerializeField] string obstacleLayerName = "Obstacle";

    [Header("Combate")]
    [SerializeField] int damage = 1;
    [SerializeField] float timeBetweenHits = 2f;

    [Header("Movimiento en cuadrícula")]
    [SerializeField] float cellSize = 1f;
    [SerializeField] float moveDuration = 0.25f;
    [SerializeField] float attackDistance = 1.5f; // Distancia de ataque (1 tile + margen)

    /* ---------------  Variables internas --------------- */
    Transform currentTarget;
    Vector3 originPoint;
    bool isFacingRight = true;

    Rigidbody2D rb;
    Animator anim;
    SpriteRenderer sr;

    bool isMoving = false;
    bool canAttack = true;

    enum State { Idle, Chase, Attack, Return, Dead }
    State currentState = State.Idle;

    // Variables para pathfinding
    private List<Vector3> currentPath = new List<Vector3>();
    private int currentPathIndex = 0;
    private Vector3 lastTargetPosition;

    // Direcciones para pathfinding (4 direcciones ortogonales)
    private Vector3Int[] directions = {
        Vector3Int.right,  // Este
        Vector3Int.left,   // Oeste  
        Vector3Int.up,     // Norte
        Vector3Int.down    // Sur
    };

    /* ------------------------ Unity ------------------------ */
    void Start()
    {
        rb = GetComponent<Rigidbody2D>();
        anim = GetComponent<Animator>();
        sr = GetComponent<SpriteRenderer>();

        if (obstacleTilemap == null)
            obstacleTilemap = GameObject.Find("Paredes")?.GetComponent<Tilemap>();

        originPoint = SnapToGrid(transform.position);
        lastTargetPosition = Vector3.zero;
    }

    void Update()
    {
        if (currentState != State.Dead && currentTarget == null)
            FindTarget();

        switch (currentState)
        {
            case State.Idle: HandleIdle(); break;
            case State.Chase: HandleChase(); break;
            case State.Attack: HandleAttack(); break;
            case State.Return: HandleReturn(); break;
        }
    }

    /* ------------------------ Búsqueda ------------------------ */
    void FindTarget()
    {
        Collider2D hit = Physics2D.OverlapCircle(transform.position, detectionRadius, enemyLayer);
        if (hit != null && hit.CompareTag("Enemy"))
            currentTarget = hit.transform;
    }

    /* ------------------------ Estados ------------------------ */
    void HandleIdle()
    {
        anim.SetTrigger("idle");
        if (currentTarget != null)
        {
            currentState = State.Chase;
            currentPath.Clear(); // Limpiar path anterior
        }
    }

    void HandleChase()
    {
        if (currentTarget == null)
        {
            currentState = State.Return;
            currentPath.Clear();
            return;
        }

        // Verificar si estamos a distancia de ataque (1 tile)
        float distanceToTarget = Vector2.Distance(transform.position, currentTarget.position);
        if (distanceToTarget <= attackDistance)
        {
            currentState = State.Attack;
            currentPath.Clear();
            return;
        }

        anim.SetTrigger("run");

        // Calcular path hacia el enemigo, pero detenerse a 1 tile de distancia
        Vector3 targetPos = GetPositionOneThileAway(currentTarget.position);

        // Recalcular path si el objetivo se movió o no tenemos path
        if (Vector3.Distance(targetPos, lastTargetPosition) > 0.1f || currentPath.Count == 0)
        {
            currentPath = FindPathBFS(transform.position, targetPos);
            currentPathIndex = 0;
            lastTargetPosition = targetPos;
        }

        // Seguir el path
        FollowPath();
    }

    void HandleAttack()
    {
        if (currentTarget == null)
        {
            currentState = State.Return;
            currentPath.Clear();
            return;
        }

        // Si el enemigo se aleja demasiado, volver a perseguir
        float distanceToTarget = Vector2.Distance(transform.position, currentTarget.position);
        if (distanceToTarget > attackDistance + 0.5f)
        {
            currentState = State.Chase;
            currentPath.Clear();
            return;
        }

        // Mirar hacia el enemigo
        Vector2 dirToEnemy = (currentTarget.position - transform.position).normalized;
        Flip(dirToEnemy);

        if (canAttack)
            StartCoroutine(PerformAttack());
    }

    void HandleReturn()
    {
        if (currentTarget != null)
        {
            currentState = State.Chase;
            currentPath.Clear();
            return;
        }

        if (Vector2.Distance(transform.position, originPoint) < 0.1f)
        {
            currentState = State.Idle;
            currentPath.Clear();
            return;
        }

        anim.SetTrigger("run");

        // Calcular path hacia el origen
        if (currentPath.Count == 0)
        {
            currentPath = FindPathBFS(transform.position, originPoint);
            currentPathIndex = 0;
        }

        // Seguir el path
        FollowPath();
    }

    /* -------------------- Pathfinding con BFS -------------------- */
    List<Vector3> FindPathBFS(Vector3 startWorld, Vector3 goalWorld)
    {
        if (obstacleTilemap == null) return new List<Vector3>();

        Vector3Int start = obstacleTilemap.WorldToCell(startWorld);
        Vector3Int goal = obstacleTilemap.WorldToCell(goalWorld);

        Queue<Vector3Int> frontier = new Queue<Vector3Int>();
        Dictionary<Vector3Int, Vector3Int> cameFrom = new Dictionary<Vector3Int, Vector3Int>();

        frontier.Enqueue(start);
        cameFrom[start] = start;

        while (frontier.Count > 0)
        {
            Vector3Int current2 = frontier.Dequeue();

            if (current2 == goal)
                break;

            foreach (Vector3Int direction in directions)
            {
                Vector3Int next = current2 + direction;

                if (cameFrom.ContainsKey(next))
                    continue;

                if (IsCellBlocked(next))
                    continue;

                frontier.Enqueue(next);
                cameFrom[next] = current2;
            }
        }

        // Reconstruir path
        List<Vector3> path = new List<Vector3>();
        if (!cameFrom.ContainsKey(goal))
            return path; // No se encontró camino

        Vector3Int current = goal;
        while (current != start)
        {
            path.Add(obstacleTilemap.GetCellCenterWorld(current));
            current = cameFrom[current];
        }

        path.Reverse();
        return path;
    }

    bool IsCellBlocked(Vector3Int cellPosition)
    {
        // Verificar si hay tile de obstáculo
        if (obstacleTilemap.HasTile(cellPosition))
            return true;

        // Verificar si hay collider en esa posición
        Vector3 worldPos = obstacleTilemap.GetCellCenterWorld(cellPosition);
        Collider2D collider = Physics2D.OverlapCircle(worldPos, 0.1f, LayerMask.GetMask(obstacleLayerName));

        return collider != null;
    }

    Vector3 GetPositionOneThileAway(Vector3 targetPosition)
    {
        Vector3 myPos = SnapToGrid(transform.position);
        Vector3 targetPos = SnapToGrid(targetPosition);

        Vector3 direction = (myPos - targetPos).normalized;
        Vector2 cardinalDir = GetCardinalDirection(direction);

        return targetPos + (Vector3)(cardinalDir * cellSize);
    }

    void FollowPath()
    {
        if (currentPath.Count == 0 || currentPathIndex >= currentPath.Count)
            return;

        Vector3 targetCell = currentPath[currentPathIndex];
        Vector2 direction = GetCardinalDirection(targetCell - transform.position);

        // Si estamos cerca del waypoint actual, pasar al siguiente
        if (Vector3.Distance(transform.position, targetCell) < 0.1f)
        {
            currentPathIndex++;
            return;
        }

        // Mover hacia el waypoint actual
        TryMove(direction);
        Flip(direction);
    }

    /* -------------------- Movimiento en cuadrícula -------------------- */
    void TryMove(Vector2 dir)
    {
        if (isMoving || dir == Vector2.zero) return;

        Vector3 targetWorldPos = SnapToGrid(transform.position) + (Vector3)(dir * cellSize);
        Vector3Int cell = obstacleTilemap.WorldToCell(targetWorldPos);

        // Verificar que la celda no esté bloqueada antes de moverse
        if (!IsCellBlocked(cell))
            StartCoroutine(MoveToCell(targetWorldPos));
    }

    IEnumerator MoveToCell(Vector3 destino)
    {
        isMoving = true;
        Vector3 origen = transform.position;
        float t = 0f;

        while (t < 1f)
        {
            t += Time.deltaTime / moveDuration;
            rb.MovePosition(Vector3.Lerp(origen, destino, t));
            yield return null;
        }

        rb.MovePosition(destino);
        isMoving = false;
    }

    /* ------------------------ Combate ------------------------ */
    IEnumerator PerformAttack()
    {
        canAttack = false;
        anim.ResetTrigger("run");
        anim.SetTrigger("attack");

        yield return new WaitForSeconds(0.35f);

        if (currentTarget != null && currentState == State.Attack)
        {
            var enemyController = currentTarget.GetComponent<EnemyController>();
            if (enemyController != null)
                enemyController.ReceiveDamage(damage);
        }

        yield return new WaitForSeconds(timeBetweenHits);
        canAttack = true;
    }

    /* ------------------------ Utilidades ------------------------ */
    Vector2 GetCardinalDirection(Vector3 rawDir)
    {
        if (Mathf.Abs(rawDir.x) > Mathf.Abs(rawDir.y))
            return rawDir.x > 0 ? Vector2.right : Vector2.left;
        else
            return rawDir.y > 0 ? Vector2.up : Vector2.down;
    }

    Vector3 SnapToGrid(Vector3 worldPos)
    {
        if (obstacleTilemap == null) return worldPos;

        Vector3Int cell = obstacleTilemap.WorldToCell(worldPos);
        return obstacleTilemap.GetCellCenterWorld(cell);
    }

    void Flip(Vector2 dir)
    {
        if (Mathf.Abs(dir.x) < 0.1f) return;

        bool shouldFaceRight = dir.x > 0;
        if (shouldFaceRight != isFacingRight)
        {
            isFacingRight = shouldFaceRight;
            sr.flipX = !isFacingRight;
        }
    }


}